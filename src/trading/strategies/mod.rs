//! Trading Strategies Framework - Enterprise Integration
//! 
//! This module provides the core strategy framework that integrates with the existing
//! arbitrage system while preserving all ML and enterprise features.

pub mod arbitrage;
pub mod momentum;
pub mod mean_reversion;
pub mod strategy_manager;

use anyhow::Result;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

// Re-export strategy implementations
pub use arbitrage::ArbitrageStrategy;
pub use momentum::MomentumStrategy;
pub use mean_reversion::MeanReversionStrategy;
pub use strategy_manager::StrategyManager;

// Re-export enterprise types from the existing arbitrage system
pub use crate::trading::arbitrage::{
    EnhancedArbitrageOpportunity, DexData, TradeResult as ArbitrageTradeResult, 
    EnhancedTradingStats
};
pub use crate::types::{MarketData, TradingOpportunity};

/// Strategy configuration for enterprise trading strategies
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyConfig {
    pub name: String,
    pub enabled: bool,
    pub capital_allocation: f64, // Percentage of total capital (0.0 to 1.0)
    pub risk_level: RiskLevel,
    pub max_position_size: f64,
    pub stop_loss_percent: f64,
    pub take_profit_percent: f64,
    pub min_confidence: f64,
    pub timeframes: Vec<Timeframe>,
}

impl Default for StrategyConfig {
    fn default() -> Self {
        Self {
            name: "Default Strategy".to_string(),
            enabled: true,
            capital_allocation: 0.1, // 10% allocation
            risk_level: RiskLevel::Moderate,
            max_position_size: 100.0,
            stop_loss_percent: 2.0,
            take_profit_percent: 4.0,
            min_confidence: 0.7,
            timeframes: vec![Timeframe::FiveMin],
        }
    }
}

/// Risk level for strategy configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RiskLevel {
    Conservative,
    Moderate,
    Aggressive,
}

/// Timeframe for strategy analysis
#[derive(Debug, Clone, Serialize, Deserialize, Copy, PartialEq, Eq, Hash)]
pub enum Timeframe {
    OneMin,
    FiveMin,
    FifteenMin,
    OneHour,
    FourHour,
    OneDay,
}

/// Trading signal generated by strategies
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategySignal {
    pub strategy_name: String,
    pub signal_type: SignalType,
    pub confidence: f64,
    pub timeframe: Timeframe,
    pub token_pair: String,
    pub price: f64,
    pub volume: f64,
    pub timestamp: DateTime<Utc>,
    pub metadata: Option<String>,
    
    // âœ… ENRIQUECIMIENTO ENTERPRISE - Campos de trading avanzados
    pub expected_profit: f64,        // Expected profit percentage
    pub stop_loss: f64,              // Stop loss price
    pub take_profit: f64,            // Take profit price
    pub reasoning: Option<String>,   // Signal reasoning/explanation
    pub risk_score: f64,             // Risk assessment score (0.0-1.0)
    pub market_conditions: Option<String>, // Market condition context
}

/// Type of trading signal
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum SignalType {
    Buy,
    Sell,
    Hold,
    StopLoss,
    TakeProfit,
}

/// Strategy performance tracking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyPerformance {
    pub strategy_name: String,
    pub total_trades: u64,
    pub winning_trades: u64,
    pub losing_trades: u64,
    pub total_profit_loss: f64,
    pub win_rate: f64,
    pub average_profit: f64,
    pub average_loss: f64,
    pub max_drawdown: f64,
    pub sharpe_ratio: f64,
    pub total_fees: f64,
    pub last_updated: DateTime<Utc>,
}

impl Default for StrategyPerformance {
    fn default() -> Self {
        Self {
            strategy_name: "Unknown".to_string(),
            total_trades: 0,
            winning_trades: 0,
            losing_trades: 0,
            total_profit_loss: 0.0,
            win_rate: 0.0,
            average_profit: 0.0,
            average_loss: 0.0,
            max_drawdown: 0.0,
            sharpe_ratio: 0.0,
            total_fees: 0.0,
            last_updated: Utc::now(),
        }
    }
}

/// Trade result for strategy performance tracking
#[derive(Debug, Clone)]
pub struct TradeResult {
    pub trade_id: String,
    pub timestamp: DateTime<Utc>,
    pub profit_loss: f64,
    pub fees: f64,
    pub success: bool,
    pub strategy_name: String,
    pub signal_confidence: f64,
    pub execution_time_ms: u64,
}

/// Core trait for all trading strategies
pub trait TradingStrategy: Send + Sync {
    /// Get the strategy name
    fn name(&self) -> &str;
    
    /// Check if strategy is enabled
    fn enabled(&self) -> bool;
    
    /// Enable/disable strategy
    fn set_enabled(&mut self, enabled: bool);
    
    /// Get strategy configuration
    fn config(&self) -> &StrategyConfig;
    
    /// Get mutable strategy configuration
    fn config_mut(&mut self) -> &mut StrategyConfig;
    
    /// Get strategy performance metrics
    fn performance(&self) -> &StrategyPerformance;
    
    /// Get mutable strategy performance metrics
    fn performance_mut(&mut self) -> &mut StrategyPerformance;
    
    /// Analyze market data and opportunity to generate trading signals
    fn analyze(
        &mut self,
        opportunity: &TradingOpportunity,
        market_data: &MarketData,
    ) -> Result<Vec<StrategySignal>>;
    
    /// Update strategy performance based on trade results
    fn update_performance(&mut self, trade_result: &TradeResult) -> Result<()>;
    
    /// Get position size based on confidence and available capital
    fn get_position_size(&self, confidence: f64, available_capital: f64) -> f64;
    
    /// Check if should exit position based on current conditions
    fn should_exit(&self, current_price: f64, entry_price: f64, signal_type: &SignalType) -> bool;
}

/// Utility functions for strategy framework
pub mod utils {
    use super::*;
    
    /// Convert ArbitrageTradeResult to TradeResult for strategy tracking
    pub fn convert_arbitrage_result(arb_result: &ArbitrageTradeResult, strategy_name: &str) -> TradeResult {
        TradeResult {
            trade_id: arb_result.trade_id.clone(),
            timestamp: arb_result.timestamp,
            profit_loss: arb_result.profit_sol,
            fees: 0.0, // TODO: Extract from ArbitrageTradeResult if available
            success: arb_result.success,
            strategy_name: strategy_name.to_string(),
            signal_confidence: arb_result.ml_confidence,
            execution_time_ms: arb_result.execution_time_ms,
        }
    }
    
    /// Calculate Sharpe ratio for strategy performance
    pub fn calculate_sharpe_ratio(returns: &[f64], risk_free_rate: f64) -> f64 {
        if returns.is_empty() {
            return 0.0;
        }
        
        let mean_return: f64 = returns.iter().sum::<f64>() / returns.len() as f64;
        let variance: f64 = returns.iter()
            .map(|r| (r - mean_return).powi(2))
            .sum::<f64>() / returns.len() as f64;
        let std_dev = variance.sqrt();
        
        if std_dev == 0.0 {
            0.0
        } else {
            (mean_return - risk_free_rate) / std_dev
        }
    }
}

impl Default for TradeResult {
    fn default() -> Self {
        Self {
            trade_id: "default".to_string(),
            timestamp: Utc::now(),
            profit_loss: 0.0,
            fees: 0.0,
            success: false,
            strategy_name: "unknown".to_string(),
            signal_confidence: 0.0,
            execution_time_ms: 0,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_strategy_config_default() {
        let config = StrategyConfig::default();
        assert_eq!(config.name, "Default Strategy");
        assert!(config.enabled);
        assert_eq!(config.capital_allocation, 0.1);
    }
    
    #[test]
    fn test_strategy_performance_default() {
        let performance = StrategyPerformance::default();
        assert_eq!(performance.total_trades, 0);
        assert_eq!(performance.win_rate, 0.0);
    }
    
    #[test]
    fn test_sharpe_ratio_calculation() {
        let returns = vec![0.1, 0.05, -0.02, 0.08, 0.03];
        let ratio = utils::calculate_sharpe_ratio(&returns, 0.02);
        assert!(ratio > 0.0);
    }
}
