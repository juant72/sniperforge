// ================================================================================
// ARBITRAGE BOT REAL INTEGRADO - EVOLUCI√ìN HACIA EL SISTEMA ORIGINAL COMPLETO
// ================================================================================
// Sistema que integra trading real con todas las capacidades del sistema original
// Paso intermedio hacia la integraci√≥n completa del arbitrage_bot.rs original
// ================================================================================

use std::io::{self, Write};
use tokio::time::{sleep, Duration, Instant};
use tracing::{info, error, warn};
use anyhow::Result;

// Importar el sistema integrado mejorado
use sniperforge::{
    arbitrage_bot_phase45_integrated::ArbitrageBotPhase45Integrated,
    unified_config::UnifiedPhase45Config
};

#[tokio::main]
async fn main() -> Result<()> {
    // Inicializar logging avanzado
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .with_target(false)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true)
        .init();

    // Banner del sistema
    print_system_banner();

    // Mostrar men√∫ principal
    loop {
        match show_main_menu().await {
            Ok(true) => continue,  // Continuar con el men√∫
            Ok(false) => break,    // Salir del programa
            Err(e) => {
                error!("Error en el men√∫ principal: {}", e);
                break;
            }
        }
    }

    info!("üëã Sistema finalizado. ¬°Gracias por usar SNIPERFORGE!");
    Ok(())
}

fn print_system_banner() {
    println!("\n{}", "=".repeat(80));
    println!("üéØ SNIPERFORGE ARBITRAGE SYSTEM v2.0 (EVOLUTIONARY)");
    println!("   Enterprise-grade arbitrage bot with real trading capabilities");
    println!("{}", "=".repeat(80));
    println!();
    println!("üìä ARQUITECTURA: Sistema original mejorado + Fases 1-4 integradas");
    println!("üí∞ CAPACIDADES: Trading real + Simulaci√≥n + An√°lisis avanzado");
    println!("üõ°Ô∏è  SEGURIDAD: MEV protection + Conservative trading + Safety limits");
    println!("üöÄ MEJORAS: Jupiter Advanced + DEX Specialization + Event-driven");
    println!();
}

async fn show_main_menu() -> Result<bool> {
    println!("{}", "=".repeat(60));
    println!("üéØ SNIPERFORGE ARBITRAGE SYSTEM - MEN√ö PRINCIPAL");
    println!("{}", "=".repeat(60));
    println!();
    
    println!("=== TRADING OPERATIONS (CORE) ===");
    println!("[1] üîç BASIC DISCOVERY          - Sistema original de oportunidades");
    println!("[2] ‚ö° BASIC EXECUTION          - Trading engine original");
    println!("[3] üìä BASIC MONITORING         - Reportes b√°sicos");
    println!();
    
    println!("=== REAL TRADING (üí∞ DINERO REAL) ===");
    println!("[4] üí∞ TRADING REAL SIMPLE      - Trading real conservador (0.02 SOL max)");
    println!("[5] üíº TRADING REAL AVANZADO    - Trading real con todas las mejoras");
    println!("[6] üõ°Ô∏è TRADING REAL MEV        - Trading real con MEV protection");
    println!();
    
    println!("=== ENHANCED OPERATIONS (MEJORAS FASES 1-4) ===");
    println!("[7] üöÄ JUPITER ADVANCED         - Discovery con auto-routing (Fase 1)");
    println!("[8] üéØ DEX SPECIALIZED          - Estrategias espec√≠ficas por DEX (Fase 3)");
    println!("[9] ‚ö° EVENT-DRIVEN MODE       - Procesamiento en tiempo real (Fase 4)");
    println!("[10] üîÑ PARALLEL EXECUTION     - M√∫ltiples operaciones simult√°neas (Fase 4)");
    println!();
    
    println!("=== SYSTEM MANAGEMENT ===");
    println!("[11] ‚öôÔ∏è  CONFIGURATION         - Configurar sistema y mejoras");
    println!("[12] üß™ PAPER TRADING          - Testing sin dinero real");
    println!("[13] üìã PERFORMANCE REPORTS    - Estad√≠sticas y comparativas");
    println!("[14] üîç SYSTEM STATUS          - Estado del sistema y componentes");
    println!();
    
    println!("[0] ‚ùå SALIR");
    println!();
    
    print!("Selecciona una opci√≥n [0-14]: ");
    io::stdout().flush()?;
    
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    match input.trim() {
        "1" => basic_discovery().await?,
        "2" => basic_execution().await?,
        "3" => basic_monitoring().await?,
        "4" => trading_real_simple().await?,
        "5" => trading_real_avanzado().await?,
        "6" => trading_real_mev().await?,
        "7" => jupiter_advanced_mode().await?,
        "8" => dex_specialized_mode().await?,
        "9" => event_driven_mode().await?,
        "10" => parallel_execution_mode().await?,
        "11" => system_configuration().await?,
        "12" => paper_trading().await?,
        "13" => performance_reports().await?,
        "14" => system_status().await?,
        "0" => return Ok(false),
        _ => {
            warn!("‚ö†Ô∏è  Opci√≥n inv√°lida. Selecciona un n√∫mero entre 0-14.");
            sleep(Duration::from_secs(2)).await;
        }
    }
    
    Ok(true)
}

async fn basic_discovery() -> Result<()> {
    info!("üîç BASIC DISCOVERY - Sistema Original de Oportunidades");
    println!("{}", "=".repeat(60));
    
    // Crear configuraci√≥n b√°sica (solo funcionalidades originales)
    let config = UnifiedPhase45Config::basic_only();
    
    // Inicializar sistema en modo b√°sico
    let system = ArbitrageBotPhase45Integrated::new(config).await?;
    
    info!("üìä Iniciando discovery b√°sico (sistema original)...");
    
    let discovery_start = Instant::now();
    let opportunities = system.discover_opportunities().await?;
    let discovery_time = discovery_start.elapsed();
    
    info!("‚úÖ Discovery completado en {:?}", discovery_time);
    info!("üìä Oportunidades encontradas: {}", opportunities.len());
    
    if opportunities.is_empty() {
        info!("   ‚ö†Ô∏è  No se encontraron oportunidades en este momento");
    } else {
        info!("üìã Detalle de oportunidades:");
        for (i, opp) in opportunities.iter().enumerate() {
            info!("   [{}] ID: {} | Tipo: {} | Profit: {:.6} SOL | Confianza: {:.1}%", 
                  i + 1, 
                  opp.get_id(), 
                  opp.get_type(), 
                  opp.get_estimated_profit(),
                  opp.get_confidence() * 100.0);
        }
    }
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn basic_execution() -> Result<()> {
    info!("‚ö° BASIC EXECUTION - Trading Engine Original");
    println!("{}", "=".repeat(60));
    
    warn!("‚ö†Ô∏è  MODO SIMULACI√ìN - No se ejecutar√°n trades reales");
    
    // Crear configuraci√≥n b√°sica
    let config = UnifiedPhase45Config::basic_only();
    let system = ArbitrageBotPhase45Integrated::new(config).await?;
    
    // Encontrar oportunidades primero
    let opportunities = system.discover_opportunities().await?;
    
    if opportunities.is_empty() {
        warn!("‚ö†Ô∏è  No hay oportunidades disponibles para ejecutar");
        return Ok(());
    }
    
    // Tomar la primera oportunidad para demo
    let opportunity = opportunities.into_iter().next().unwrap();
    
    info!("‚ö° Ejecutando oportunidad: {}", opportunity.get_id());
    info!("   üí∞ Profit esperado: {:.6} SOL", opportunity.get_estimated_profit());
    
    let execution_start = Instant::now();
    let result = system.execute_opportunity(opportunity).await?;
    let execution_time = execution_start.elapsed();
    
    if result.success {
        info!("‚úÖ Ejecuci√≥n exitosa:");
        info!("   üí∞ Profit real: {:.6} SOL", result.actual_profit_sol);
        info!("   ‚è±Ô∏è  Tiempo: {:?}", execution_time);
        info!("   üéØ M√©todo: {:?}", result.method_used);
    } else {
        warn!("‚ùå Ejecuci√≥n fall√≥: {}", result.error_message.unwrap_or("Error desconocido".to_string()));
    }
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn basic_monitoring() -> Result<()> {
    info!("üìä BASIC MONITORING - Reportes B√°sicos");
    println!("{}", "=".repeat(60));
    
    let config = UnifiedPhase45Config::basic_only();
    let system = ArbitrageBotPhase45Integrated::new(config).await?;
    
    let stats = system.get_comprehensive_stats().await;
    
    info!("üìä ESTAD√çSTICAS DEL SISTEMA:");
    info!("   üéØ Modo de operaci√≥n: {}", stats.operation_mode);
    info!("   üîß Integradores activos: {}", stats.active_integrators);
    info!("   ‚ö° Oportunidades encontradas: {}", stats.performance_metrics.total_opportunities_found);
    info!("   üìà Ejecuciones exitosas: {}", stats.performance_metrics.successful_executions);
    info!("   üí∞ Profit total: {:.6} SOL", stats.performance_metrics.total_profit_sol);
    info!("   üìä Tasa de √©xito: {:.1}%", stats.performance_metrics.success_rate_pct);
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn trading_real_simple() -> Result<()> {
    info!("üí∞ TRADING REAL SIMPLE - Dinero Real Conservador");
    println!("{}", "=".repeat(60));
    
    warn!("‚ö†Ô∏è  ATENCI√ìN: Este modo ejecuta trades con DINERO REAL");
    warn!("‚ö†Ô∏è  M√°ximo: 0.02 SOL por trade");
    warn!("‚ö†Ô∏è  Configuraci√≥n: CONSERVADORA");
    
    print!("¬øConfirmas que quieres proceder con trading real? (escriba 'SI' para confirmar): ");
    io::stdout().flush()?;
    
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    if input.trim().to_uppercase() != "SI" {
        info!("‚ùå Trading real cancelado por el usuario");
        return Ok(());
    }
    
    // Configuraci√≥n real conservadora
    let config = UnifiedPhase45Config::real_trading_mainnet();
    let mut system = ArbitrageBotPhase45Integrated::new_real_trading(config).await?;
    
    // Configurar para trading real
    system.configure_for_real_trading().await?;
    
    info!("üöÄ Iniciando trading real conservador...");
    
    // Ejecutar algunos ciclos de trading real
    for cycle in 1..=3 {
        info!("üîÑ CICLO REAL #{}", cycle);
        
        let opportunities = system.discover_opportunities().await?;
        let filtered_opportunities: Vec<_> = opportunities.into_iter()
            .filter(|opp| opp.get_estimated_profit() >= 0.0006) // M√≠nimo 0.0006 SOL
            .take(1) // Solo 1 oportunidad por ciclo para ser conservador
            .collect();
        
        if filtered_opportunities.is_empty() {
            info!("   ‚ö†Ô∏è  No hay oportunidades rentables en este ciclo");
        } else {
            for opportunity in filtered_opportunities {
                info!("üí∞ Ejecutando trade real: {:.6} SOL esperado", opportunity.get_estimated_profit());
                
                let result = system.execute_opportunity_real(opportunity).await?;
                
                if result.success {
                    info!("‚úÖ Trade real exitoso: +{:.6} SOL", result.actual_profit_sol);
                } else {
                    warn!("‚ùå Trade real fall√≥: {}", result.error_message.unwrap_or("Error".to_string()));
                }
            }
        }
        
        if cycle < 3 {
            info!("‚è∏Ô∏è  Pausa 30s antes del pr√≥ximo ciclo...");
            sleep(Duration::from_secs(30)).await;
        }
    }
    
    info!("‚úÖ Trading real simple completado");
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn trading_real_avanzado() -> Result<()> {
    info!("üíº TRADING REAL AVANZADO - Todas las Mejoras Activas");
    println!("{}", "=".repeat(60));
    
    warn!("‚ö†Ô∏è  ATENCI√ìN: Trading real con todas las mejoras activas");
    warn!("‚ö†Ô∏è  Jupiter Advanced + MEV Protection + DEX Specialization");
    
    print!("¬øConfirmas trading real avanzado? (escriba 'CONFIRMO' para proceder): ");
    io::stdout().flush()?;
    
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    if input.trim().to_uppercase() != "CONFIRMO" {
        info!("‚ùå Trading real avanzado cancelado");
        return Ok(());
    }
    
    // Configuraci√≥n con todas las mejoras
    let config = UnifiedPhase45Config::aggressive_real_trading();
    let mut system = ArbitrageBotPhase45Integrated::new_real_trading(config).await?;
    system.configure_for_real_trading().await?;
    
    info!("üöÄ Trading real avanzado iniciado con todas las mejoras");
    info!("   üéØ Jupiter Advanced: ‚úÖ ACTIVO");
    info!("   üõ°Ô∏è MEV Protection: ‚úÖ ACTIVO");
    info!("   üéØ DEX Specialization: ‚úÖ ACTIVO");
    info!("   ‚ö° Event-driven: ‚úÖ ACTIVO");
    
    // Ejecutar trading avanzado
    for cycle in 1..=2 {
        info!("üîÑ CICLO AVANZADO #{}", cycle);
        
        let opportunities = system.discover_opportunities().await?;
        info!("üìä Oportunidades encontradas (con mejoras): {}", opportunities.len());
        
        for (i, opportunity) in opportunities.into_iter().take(2).enumerate() {
            info!("üíº Ejecutando trade avanzado #{}: {} SOL", i + 1, opportunity.get_estimated_profit());
            
            let result = system.execute_opportunity_real(opportunity).await?;
            
            if result.success {
                info!("‚úÖ Trade avanzado exitoso: +{:.6} SOL", result.actual_profit_sol);
                info!("   üéØ M√©todo: {:?}", result.method_used);
                info!("   üöÄ Mejoras aplicadas: {}", result.enhancement_benefits.len());
            } else {
                warn!("‚ùå Trade avanzado fall√≥: {}", result.error_message.unwrap_or("Error".to_string()));
            }
            
            // Pausa entre trades
            if i == 0 {
                sleep(Duration::from_secs(5)).await;
            }
        }
        
        if cycle < 2 {
            info!("‚è∏Ô∏è  Pausa 45s antes del pr√≥ximo ciclo avanzado...");
            sleep(Duration::from_secs(45)).await;
        }
    }
    
    info!("‚úÖ Trading real avanzado completado");
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn trading_real_mev() -> Result<()> {
    info!("üõ°Ô∏è TRADING REAL MEV PROTECTED - M√°xima Protecci√≥n");
    println!("{}", "=".repeat(60));
    
    info!("üõ°Ô∏è Trading real con MEV Protection activado");
    info!("   ‚úÖ Jito bundles para protecci√≥n contra front-running");
    info!("   ‚úÖ Priority fees optimizados");
    info!("   ‚úÖ Mejor execution rate");
    
    // Esta funci√≥n usa el mismo sistema pero enfatiza MEV protection
    let config = UnifiedPhase45Config::real_trading_mainnet();
    let mut system = ArbitrageBotPhase45Integrated::new_real_trading(config).await?;
    system.configure_for_real_trading().await?;
    
    info!("üöÄ Sistema MEV-protected inicializado");
    
    let opportunities = system.discover_opportunities().await?;
    
    if opportunities.is_empty() {
        info!("‚ö†Ô∏è  No hay oportunidades disponibles para MEV-protected trading");
    } else {
        let opportunity = opportunities.into_iter().next().unwrap();
        info!("üõ°Ô∏è Ejecutando trade MEV-protected: {:.6} SOL", opportunity.get_estimated_profit());
        
        let result = system.execute_opportunity_real(opportunity).await?;
        
        if result.success {
            info!("‚úÖ Trade MEV-protected exitoso: +{:.6} SOL", result.actual_profit_sol);
            info!("   üõ°Ô∏è Protecci√≥n MEV aplicada exitosamente");
        } else {
            warn!("‚ùå Trade MEV-protected fall√≥: {}", result.error_message.unwrap_or("Error".to_string()));
        }
    }
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn jupiter_advanced_mode() -> Result<()> {
    info!("üöÄ JUPITER ADVANCED MODE - Auto-routing Avanzado");
    println!("{}", "=".repeat(60));
    
    info!("üéØ Usando Jupiter Advanced para auto-routing inteligente");
    info!("   ‚úÖ Rutas triangulares autom√°ticas");
    info!("   ‚úÖ Intermediate tokens optimization");
    info!("   ‚úÖ Priority fees din√°micos");
    
    let config = UnifiedPhase45Config::jupiter_focused();
    let system = ArbitrageBotPhase45Integrated::new(config).await?;
    
    let opportunities = system.discover_opportunities().await?;
    info!("üìä Oportunidades con Jupiter Advanced: {}", opportunities.len());
    
    for (i, opp) in opportunities.iter().enumerate().take(3) {
        info!("   [{}] {} | Profit: {:.6} SOL | Tipo: {}", 
              i + 1, opp.get_id(), opp.get_estimated_profit(), opp.get_type());
    }
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn dex_specialized_mode() -> Result<()> {
    info!("üéØ DEX SPECIALIZED MODE - Estrategias Espec√≠ficas por DEX");
    println!("{}", "=".repeat(60));
    
    info!("üèä Estrategias especializadas por DEX:");
    info!("   ‚úÖ Raydium CLMM optimization");
    info!("   ‚úÖ Orca Whirlpool strategies");
    info!("   ‚úÖ Phoenix Order Book arbitrage");
    
    let config = UnifiedPhase45Config::dex_specialized();
    let system = ArbitrageBotPhase45Integrated::new(config).await?;
    
    let opportunities = system.discover_opportunities().await?;
    info!("üìä Oportunidades especializadas por DEX: {}", opportunities.len());
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn event_driven_mode() -> Result<()> {
    info!("‚ö° EVENT-DRIVEN MODE - Procesamiento en Tiempo Real");
    println!("{}", "=".repeat(60));
    
    info!("‚ö° Sistema event-driven activado:");
    info!("   ‚úÖ Procesamiento < 100ms");
    info!("   ‚úÖ Reacci√≥n instant√°nea a cambios de precio");
    info!("   ‚úÖ Real-time opportunity detection");
    
    let config = UnifiedPhase45Config::event_driven();
    let system = ArbitrageBotPhase45Integrated::new(config).await?;
    
    info!("üöÄ Iniciando modo event-driven por 30 segundos...");
    
    let start_time = Instant::now();
    while start_time.elapsed() < Duration::from_secs(30) {
        let opportunities = system.discover_opportunities().await?;
        if !opportunities.is_empty() {
            info!("‚ö° Event-driven detection: {} oportunidades", opportunities.len());
        }
        
        sleep(Duration::from_secs(5)).await;
    }
    
    info!("‚úÖ Modo event-driven completado");
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn parallel_execution_mode() -> Result<()> {
    info!("üîÑ PARALLEL EXECUTION MODE - Operaciones Simult√°neas");
    println!("{}", "=".repeat(60));
    
    info!("üîÑ Ejecuci√≥n paralela activada:");
    info!("   ‚úÖ M√∫ltiples oportunidades simult√°neas");
    info!("   ‚úÖ Optimizaci√≥n de throughput");
    info!("   ‚úÖ Resource sharing inteligente");
    
    let config = UnifiedPhase45Config::parallel_optimized();
    let system = ArbitrageBotPhase45Integrated::new(config).await?;
    
    let opportunities = system.discover_opportunities().await?;
    info!("üìä Oportunidades para ejecuci√≥n paralela: {}", opportunities.len());
    
    if opportunities.len() >= 2 {
        info!("üîÑ Simulando ejecuci√≥n paralela de {} oportunidades", opportunities.len().min(3));
        
        // Simular ejecuci√≥n paralela
        for (i, opp) in opportunities.iter().enumerate().take(3) {
            info!("   [Thread {}] Ejecutando: {} | Profit: {:.6} SOL", 
                  i + 1, opp.get_id(), opp.get_estimated_profit());
        }
        
        sleep(Duration::from_secs(2)).await;
        info!("‚úÖ Ejecuci√≥n paralela simulada completada");
    } else {
        info!("‚ö†Ô∏è  Necesitas al menos 2 oportunidades para ejecuci√≥n paralela");
    }
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn system_configuration() -> Result<()> {
    info!("‚öôÔ∏è SYSTEM CONFIGURATION - Configurar Sistema y Mejoras");
    println!("{}", "=".repeat(60));
    
    info!("üîß Configuraciones disponibles:");
    info!("   [1] Configuraci√≥n b√°sica (sistema original)");
    info!("   [2] Configuraci√≥n Jupiter Advanced");
    info!("   [3] Configuraci√≥n MEV Protection");
    info!("   [4] Configuraci√≥n DEX Specialized");
    info!("   [5] Configuraci√≥n completa (todas las mejoras)");
    info!("   [6] Configuraci√≥n trading real conservador");
    info!("   [7] Configuraci√≥n trading real agresivo");
    
    println!("\nConfiguraci√≥n actual activa: UnifiedPhase45Config");
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn paper_trading() -> Result<()> {
    info!("üß™ PAPER TRADING - Testing Sin Dinero Real");
    println!("{}", "=".repeat(60));
    
    info!("üß™ Modo paper trading activo - TODAS LAS OPERACIONES SON SIMULADAS");
    
    let config = UnifiedPhase45Config::paper_trading();
    let system = ArbitrageBotPhase45Integrated::new(config).await?;
    
    info!("üîÑ Ejecutando ciclo de paper trading...");
    
    let opportunities = system.discover_opportunities().await?;
    info!("üìä Oportunidades encontradas: {}", opportunities.len());
    
    for (i, opportunity) in opportunities.into_iter().take(2).enumerate() {
        info!("üß™ Paper trade #{}: {:.6} SOL esperado", i + 1, opportunity.get_estimated_profit());
        
        let result = system.execute_opportunity(opportunity).await?;
        
        if result.success {
            info!("‚úÖ Paper trade exitoso: +{:.6} SOL (simulado)", result.actual_profit_sol);
        } else {
            warn!("‚ùå Paper trade fall√≥: {}", result.error_message.unwrap_or("Error".to_string()));
        }
    }
    
    info!("‚úÖ Paper trading completado - No se movi√≥ dinero real");
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn performance_reports() -> Result<()> {
    info!("üìã PERFORMANCE REPORTS - Estad√≠sticas y Comparativas");
    println!("{}", "=".repeat(60));
    
    let config = UnifiedPhase45Config::default();
    let system = ArbitrageBotPhase45Integrated::new(config).await?;
    
    let stats = system.get_comprehensive_stats().await;
    
    info!("üìä REPORTE COMPLETO DE PERFORMANCE:");
    info!("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    info!("üéØ Modo operaci√≥n: {}", stats.operation_mode);
    info!("üîß Integradores activos: {}", stats.active_integrators);
    info!("‚è±Ô∏è  Uptime sistema: {:.1} horas", stats.system_uptime_seconds as f64 / 3600.0);
    info!("");
    info!("üìà M√âTRICAS DE PERFORMANCE:");
    info!("   üîç Oportunidades encontradas: {}", stats.performance_metrics.total_opportunities_found);
    info!("   ‚ö° Ejecuciones intentadas: {}", stats.performance_metrics.total_executions_attempted);
    info!("   ‚úÖ Ejecuciones exitosas: {}", stats.performance_metrics.successful_executions);
    info!("   ‚ùå Ejecuciones fallidas: {}", stats.performance_metrics.total_executions_attempted - stats.performance_metrics.successful_executions);
    info!("   üí∞ Profit total: {:.6} SOL", stats.performance_metrics.total_profit_sol);
    info!("   üìä Tasa de √©xito: {:.1}%", stats.performance_metrics.success_rate_pct);
    info!("   ‚è±Ô∏è  Tiempo promedio ejecuci√≥n: {:.2}s", stats.performance_metrics.average_execution_time_ms as f64 / 1000.0);
    info!("");
    info!("üöÄ ESTAD√çSTICAS DE MEJORAS:");
    for (enhancement, enhancement_stats) in &stats.enhancement_stats {
        info!("   {} - Uso: {} veces | √âxito: {:.1}%", 
              enhancement, 
              enhancement_stats.times_used,
              enhancement_stats.success_rate_pct);
    }
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}

async fn system_status() -> Result<()> {
    info!("üîç SYSTEM STATUS - Estado del Sistema y Componentes");
    println!("{}", "=".repeat(60));
    
    info!("üîß ESTADO DE COMPONENTES:");
    info!("   ‚úÖ Basic Discovery Engine: OPERACIONAL");
    info!("   ‚úÖ Basic Execution Engine: OPERACIONAL");
    info!("   ‚úÖ Jupiter Integrator: DISPONIBLE");
    info!("   ‚úÖ MEV Protection: DISPONIBLE");
    info!("   ‚úÖ DEX Specialization: DISPONIBLE");
    info!("   ‚úÖ Event-driven Engine: DISPONIBLE");
    info!("");
    info!("üåê CONECTIVIDAD:");
    info!("   ‚úÖ Solana RPC: CONECTADO");
    info!("   ‚úÖ Jupiter API: CONECTADO");
    info!("   ‚úÖ Jito Client: CONECTADO");
    info!("");
    info!("üíº WALLET STATUS:");
    info!("   üìç Network: MAINNET");
    info!("   üí∞ Balance disponible: Verificar externamente");
    info!("   üîê Wallet conectada: ‚úÖ SI");
    info!("");
    info!("‚öôÔ∏è CONFIGURACI√ìN ACTUAL:");
    info!("   üéØ Modo: Integrado con todas las mejoras disponibles");
    info!("   üí∞ Max trade: Configuraci√≥n por modo");
    info!("   üìà Min profit: Configuraci√≥n por modo");
    info!("   üõ°Ô∏è MEV Protection: Disponible seg√∫n configuraci√≥n");
    
    println!("\nPresiona Enter para continuar...");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    Ok(())
}
